"""
문제 및 강의 출처: https://youtu.be/2zjoKjt97vQ?si=PpaK6DISWRoLL4Id

유형: 그리디
제목: 모험가 길드

<문제>
- 한 마을에 모험가가 N명 있습니다. 모험가 길드에서는 N명의 모험가를 대상으로 '공포도'를 측정했는데, '공포도'가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어집니다.
- 모험가 길드장인 동빈이는 모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있도록 규정했습니다.
- 동빈이는 최대 몇 개의 모험가 그룹을 만들 수 있는지 궁금합니다. N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹 수의 최댓값을 구하는 프로그램을 작성하세요.

- 1 <= N <= 100,000
- 시간제한 1초, 메모리 제한 128MB


<나의 답안 해석>
시간제한과 N 값의 범위를 보았을 때 O(N Log N) 해결책을 쓸 수 있을 것으로 예상된다.

따라서 공포도 리스트를 내림차순으로 정렬한 뒤 정렬된 리스트를 순회하는 전략을 선택했다.

==>> 내림차순으로 정렬해서 찾는 나의 답은 틀렸다. 반례를 랜덤 input을 생성해서 넣어보는 방식으로 찾아냈다.

<내림차순 정렬 방식에 대한 반례>
desc sol : 1
asc sol : 3
[1, 1, 1, 4, 6, 6, 21, 25, 34]

"""

# 오답인지 정답인지 모르겠다. 내림차순 풀이가 틀린건가?
# 오름차순에서는 요구하는 공포도 값이 작은 것부터 살피기 때문에 최대한의 그룹 개수를 추구할 수 있을 것 같긴하다. 내림차순 풀이는 공포도가 큰 것에 대해 그룹을 만들면서 가기 때문에 최대 그룹 개수를 추구하기 어려울 것 같다. 하지만 내림차순 풀이가 틀린 반례를 찾지 못하겠어서 문제이다. ==>> 찾았다!
# [1, 1, 1, 4, 6 ,6]
N = int(input())
horrors = list(map(int, input().split()))

horrors.sort(reverse=True)

cnt = 0
i = 0
while i < len(horrors):
    horror = horrors[i]
    if (i + horror - 1) < len(horrors):
        cnt += 1
        i += horror
    else:
        i += 1  

print(cnt)



### 동영상 속에서 주어진 답 ###

# 오름차순 정렬을 이용한 풀이이다.

n = int(input())
data = list(map(int, input().split()))
data.sort()

result = 0
count = 0

for i in data:
    count += 1
    if count >= i:
        result += 1
        count = 0

print(result)